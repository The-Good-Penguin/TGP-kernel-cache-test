From d41b154b8896fa7b606c1cdc0f193101dbd895e4 Mon Sep 17 00:00:00 2001
From: acampanella-thegoodpenguin <acampanella@thegoodpenguin.co.uk>
Date: Fri, 29 Aug 2025 14:30:06 +0100
Subject: [PATCH 2/7] drivers/misc: add boot-time module caching

---
 drivers/misc/Kconfig     |   6 ++
 drivers/misc/Makefile    |   1 +
 drivers/misc/bootcache.c | 115 +++++++++++++++++++++++++++++++++++++++
 drivers/misc/bootcache.h |  33 +++++++++++
 4 files changed, 155 insertions(+)
 create mode 100644 drivers/misc/bootcache.c
 create mode 100644 drivers/misc/bootcache.h

diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index b9c11f67315f..87da68930d46 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -381,6 +381,12 @@ config SENSORS_BH1770
 	   To compile this driver as a module, choose M here: the
 	   module will be called bh1770glc. If unsure, say N here.
 
+config BOOT_CACHE
+	bool "Boot-time cache for kernel subsystems"
+	help
+	  Enable caching framework for kernel subsystems to store
+	  configuration data and speed up subsequent boots.
+
 config SENSORS_APDS990X
 	 tristate "APDS990X combined als and proximity sensors"
 	 depends on I2C
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index e2e66f5f4fb8..0898766fc528 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -20,6 +20,7 @@ obj-$(CONFIG_RPMB)		+= rpmb-core.o
 obj-$(CONFIG_QCOM_COINCELL)	+= qcom-coincell.o
 obj-$(CONFIG_QCOM_FASTRPC)	+= fastrpc.o
 obj-$(CONFIG_SENSORS_BH1770)	+= bh1770glc.o
+obj-$(CONFIG_BOOT_CACHE)    += bootcache.o
 obj-$(CONFIG_SENSORS_APDS990X)	+= apds990x.o
 obj-$(CONFIG_ENCLOSURE_SERVICES) += enclosure.o
 obj-$(CONFIG_KGDB_TESTS)	+= kgdbts.o
diff --git a/drivers/misc/bootcache.c b/drivers/misc/bootcache.c
new file mode 100644
index 000000000000..8b0a94b46edb
--- /dev/null
+++ b/drivers/misc/bootcache.c
@@ -0,0 +1,115 @@
+// SPDX-License-Identifier: GPL-2.0
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/hashtable.h>
+#include <linux/string.h>
+#include <linux/stringhash.h>
+#include <linux/types.h>
+#include <linux/spinlock.h>
+#include <linux/errno.h>
+
+#include <linux/bootcache.h>
+
+#define BOOTCACHE_HASH_BITS 6  /* 64 buckets */
+
+static DEFINE_HASHTABLE(bootcache_table, BOOTCACHE_HASH_BITS);
+static DEFINE_SPINLOCK(bootcache_lock);
+
+struct bootcache_entry {
+	struct hlist_node node;
+	char *key;
+	u32 value;
+};
+
+int bootcache_get_u32(const char *name, u32 *out_val)
+{
+	struct bootcache_entry *entry;
+	u32 hash;
+	int ret = -ENOENT;
+
+	if (!name || !out_val)
+		return -EINVAL;
+
+	hash = full_name_hash(NULL, name, strlen(name));
+
+	spin_lock(&bootcache_lock);
+	hash_for_each_possible(bootcache_table, entry, node, hash) {
+		if (strcmp(entry->key, name) == 0) {
+			*out_val = entry->value;
+			ret = 0;
+			goto unlock;
+		}
+	}
+
+unlock:
+	spin_unlock(&bootcache_lock);
+	return ret;
+}
+EXPORT_SYMBOL(bootcache_get_u32);
+
+int bootcache_set_u32(const char *name, u32 val)
+{
+	struct bootcache_entry *entry, *new_entry = NULL;
+	u32 hash;
+	int ret = 0;
+
+	if (!name)
+		return -EINVAL;
+
+	new_entry = kzalloc(sizeof(*new_entry), GFP_KERNEL);
+	if (!new_entry)
+		return -ENOMEM;
+
+	new_entry->key = kstrdup(name, GFP_KERNEL);
+	if (!new_entry->key) {
+		kfree(new_entry);
+		return -ENOMEM;
+	}
+	new_entry->value = val;
+
+	hash = full_name_hash(NULL, name, strlen(name));
+
+	spin_lock(&bootcache_lock);
+
+	hash_for_each_possible(bootcache_table, entry, node, hash) {
+		if (strcmp(entry->key, name) == 0) {
+			entry->value = val;
+			ret = 0;
+			goto unlock;
+		}
+	}
+
+	hash_add(bootcache_table, &new_entry->node, hash);
+	new_entry = NULL;
+
+unlock:
+	spin_unlock(&bootcache_lock);
+
+	/* Avoid possible race condition if multithreaded */
+	if (new_entry) {
+		kfree(new_entry->key);
+		kfree(new_entry);
+	}
+
+	/* Write to persistent storage */
+	if (ret == 0)
+		bootcache_writeout();
+
+	return ret;
+}
+EXPORT_SYMBOL(bootcache_set_u32);
+
+void bootcache_writeout(void)
+{
+	/* TODO: Implement persistent storage backend */
+}
+EXPORT_SYMBOL(bootcache_writeout);
+
+static int __init bootcache_init(void)
+{
+	pr_info("bootcache: backend loaded\n");
+	return 0;
+}
+
+core_initcall(bootcache_init);
diff --git a/drivers/misc/bootcache.h b/drivers/misc/bootcache.h
new file mode 100644
index 000000000000..d1da9ec6b6aa
--- /dev/null
+++ b/drivers/misc/bootcache.h
@@ -0,0 +1,33 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _LINUX_BOOTCACHE_H
+#define _LINUX_BOOTCACHE_H
+
+#include <linux/types.h>
+
+/**
+ * bootcache_get_u32 - Retrieve a u32 value from the cache
+ * @name: Key to look up
+ * @out_val: Pointer to store the retrieved value
+ *
+ * Returns: 0 on success, -EINVAL for invalid parameters, -ENOENT if not found
+ */
+int bootcache_get_u32(const char *name, u32 *out_val);
+
+/**
+ * bootcache_set_u32 - Store a u32 value in the cache
+ * @name: Key to store under
+ * @val: Value to store
+ *
+ * Returns: 0 on success, -EINVAL for invalid parameters, -ENOMEM on allocation failure
+ */
+int bootcache_set_u32(const char *name, u32 val);
+
+/**
+ * bootcache_writeout - Write cache contents to persistent storage
+ *
+ * Flushes any pending cache entries to persistent storage.
+ * Implementation depends on the active backend.
+ */
+void bootcache_writeout(void);
+
+#endif /* _LINUX_BOOTCACHE_H */
-- 
2.43.0

