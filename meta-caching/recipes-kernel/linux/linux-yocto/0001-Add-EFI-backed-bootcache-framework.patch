From c782a6491c77f0feb5021f51b41da2c63a6f0da0 Mon Sep 17 00:00:00 2001
From: Marc Kelly <mkelly@thegoodpenguin.co.uk>
Date: Fri, 6 Sep 2024 16:48:36 +0100
Subject: [PATCH] Add EFI backed bootcache framework.

Reads variables from EFI variable store and caches those required.
Allows the usage of a u32 get/set function pair to get and update the
variables.
At reboot any modified variables are saved back to the EFI variable
store.
---
 drivers/firmware/efi/Kconfig         |   5 +
 drivers/firmware/efi/Makefile        |   1 +
 drivers/firmware/efi/efi-bootcache.c | 635 +++++++++++++++++++++++++++
 include/linux/efi-bootcache.h        |  11 +
 4 files changed, 652 insertions(+)
 create mode 100644 drivers/firmware/efi/efi-bootcache.c
 create mode 100644 include/linux/efi-bootcache.h

diff --git a/drivers/firmware/efi/Kconfig b/drivers/firmware/efi/Kconfig
index 2c3dac5ecb36..2f1cad9732c8 100644
--- a/drivers/firmware/efi/Kconfig
+++ b/drivers/firmware/efi/Kconfig
@@ -14,6 +14,11 @@ config EFI_VARS
 	  legacy users: new users should use the efivarfs filesystem
 	  instead.
 
+config EFI_BOOTCACHE
+	bool "EFI Bootcache Framework"
+	depends on EFI
+	default y
+
 config EFI_ESRT
 	bool
 	depends on EFI && !IA64
diff --git a/drivers/firmware/efi/Makefile b/drivers/firmware/efi/Makefile
index c02ff25dd477..b17f4be715f8 100644
--- a/drivers/firmware/efi/Makefile
+++ b/drivers/firmware/efi/Makefile
@@ -12,6 +12,7 @@ KASAN_SANITIZE_runtime-wrappers.o	:= n
 
 obj-$(CONFIG_ACPI_BGRT) 		+= efi-bgrt.o
 obj-$(CONFIG_EFI)			+= efi.o vars.o reboot.o memattr.o tpm.o
+obj-$(CONFIG_EFI_BOOTCACHE)			+= efi-bootcache.o
 obj-$(CONFIG_EFI)			+= memmap.o
 ifneq ($(CONFIG_EFI_CAPSULE_LOADER),)
 obj-$(CONFIG_EFI)			+= capsule.o
diff --git a/drivers/firmware/efi/efi-bootcache.c b/drivers/firmware/efi/efi-bootcache.c
new file mode 100644
index 000000000000..28491c214e96
--- /dev/null
+++ b/drivers/firmware/efi/efi-bootcache.c
@@ -0,0 +1,635 @@
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/delay.h>
+#include <linux/efi.h>
+#include <linux/efi-bootcache.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/nls.h>
+#include <linux/notifier.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+#include <linux/slab.h>
+#include <linux/ucs2_string.h>
+#include <linux/uuid.h>
+
+#define EFI_BOOTCACHE_VERSION "0.10"
+#define EFI_BOOTCACHE_DATE "2024-Sept-03"
+
+/* 
+ * GUID we are storing data under, to keep it seperate from
+ * any existing system variables
+ */
+#define EFI_BOOTCACHE_GUID	EFI_GUID(0xf0cbe7d9, 0x5f91, 0x45a7, 0x80, 0xa7, 0xa1, 0x2d, 0xc9, 0x86, 0x02, 0x13)
+
+/* Turn on some debugging bits */
+#define TESTING_MODE 1
+
+static LIST_HEAD(efi_bootcache_list);
+static int envCount = 0;
+
+struct bootcache_node {
+	struct efivar_entry efi_entry;
+	const char *device_name;
+	const char *var_name;
+	bool is_modified;
+};
+
+/* Use this to hold the bits we need when iterating though the list via callbacks. */
+struct bootcache_search {
+	const char *device_name;
+	const char *var_name;
+	struct bootcache_node *found_node;
+};
+
+static inline bool is_warmreset(void);
+static int efi_bootcache_print_entry(struct efivar_entry *, void *);
+static int efi_bootcache_free(struct bootcache_node *);
+static int efi_bootcache_find(struct efivar_entry *, void *);
+static int efi_bootcache_print_entry(struct efivar_entry *, void *);
+static int efi_bootcache_write_entry(struct efivar_entry *, void *);
+static struct bootcache_node *efi_bootcache_new(struct platform_device *,
+						char *);
+static int efi_bootcache_halt(struct notifier_block *, unsigned long, void *);
+
+#ifdef TESTING_MODE
+static void efi_print_variablename(efi_char16_t * name, efi_guid_t vendor);
+#endif
+
+static struct notifier_block bootcache_notifier = {
+	.notifier_call = efi_bootcache_halt,
+};
+
+static int notifier_disabled = 0;
+static bool cache_ready = false;
+
+/* Status of the warm reset */
+static bool warmreset = false;
+
+/* Return warm reset status */
+static inline bool is_warmreset(void)
+{
+	return warmreset;
+}
+
+/* Check for the parameter being set */
+static int __init warmreset_match(char *str)
+{
+	if (!strcmp(str, "1")) {
+		warmreset = true;
+	}
+	return 1;
+}
+
+__setup("warm-reset=", warmreset_match);
+
+/*
+ * shutdown notifier, so we can write out any changed variables when the
+ * kernel goes into a shutdown. This happens before everything is unloaded
+ * and it's fine to block here (which is what the writing does)
+ */
+static int efi_bootcache_halt(struct notifier_block *nb, unsigned long event,
+			      void *buf)
+{
+	if (notifier_disabled || !cache_ready)
+		return NOTIFY_OK;
+
+	notifier_disabled = 1;
+
+	pr_debug("Rebooting, writing out changed variables\n");
+	bootcache_writeout();
+	return NOTIFY_OK;
+}
+
+/*
+ * Dumps out the variable entry to the console
+ * Used for debugging
+ */
+
+static int efi_bootcache_print_entry(struct efivar_entry *entry, void *data)
+{
+	struct bootcache_node *cache_node = (struct bootcache_node *)entry;
+	struct efi_variable *var = &entry->var;
+
+	pr_debug("%s:%s-%pUb (%s)\n", cache_node->device_name,
+		 cache_node->var_name, &entry->var.VendorGuid,
+		 cache_node->is_modified ? "Modified" : "Unmodified");
+	if (var->DataSize) {
+		pr_debug("  Size: %ld\n", var->DataSize);
+		print_hex_dump(KERN_DEBUG, "  DATA: ", DUMP_PREFIX_NONE, 16, 1,
+			       &var->Data, var->DataSize, 1);
+	} else
+		pr_info("  EMPTY\n");
+	return 0;
+}
+
+/*
+ * Delete a node, used when the memeory needs to be free'd back up
+ * Only used when we fail to add a new variable for some reason.
+ */
+
+static int efi_bootcache_free(struct bootcache_node *bnode)
+{
+	pr_info("efi_bootcache_free (0x%px)\n", bnode);
+
+	if (bnode->var_name)
+		kfree(bnode->var_name);
+	if (bnode->device_name)
+		kfree(bnode->device_name);
+	kfree(bnode);
+
+	return 0;
+}
+
+/* 
+ * Write out an entry to the efi subsystem if it has changed.
+ * This saves wear on any flash by not writing it every time.
+ */
+
+static int efi_bootcache_write_entry(struct efivar_entry *entry, void *dummy)
+{
+	int ret;
+	struct bootcache_node *bnode = (struct bootcache_node *)entry;
+	struct efi_variable *var = &entry->var;
+
+	/* Check if the variable is unmodified, no need to operate on it in that case */
+	if (!bnode->is_modified)
+		return 0;
+
+	if (bnode->device_name)
+		pr_debug("Writing out variable %s:%s size = %ld\n",
+			 bnode->device_name, bnode->var_name, var->DataSize);
+	else
+		pr_debug("Writing out variable %s size = %ld\n",
+			 bnode->var_name, var->DataSize);
+
+	ret = efivar_entry_set_safe(var->VariableName, var->VendorGuid,
+				    var->Attributes, true,
+				    var->DataSize, &var->Data);
+	if (ret)
+		pr_err("set_variable_nonblocking() failed : %d\n", ret);
+	else
+		bnode->is_modified = false;
+	return ret;
+}
+
+/*
+ * Create a new variable from scratch, does not add the data
+ */
+
+static struct bootcache_node *efi_bootcache_new(struct platform_device *pdev,
+						char *var_name)
+{
+	struct bootcache_node *new_bnode;
+	struct efivar_entry *entry;
+	int var_name_size;
+	int device_name_size;
+	int destSize = EFI_VAR_NAME_LEN / sizeof(efi_char16_t);
+	int sizeCopied = 0;
+
+	new_bnode = kmalloc(sizeof(*new_bnode), GFP_KERNEL);
+	pr_debug("New node allocated at %px\n", new_bnode);
+	if (!new_bnode)
+		return NULL;
+	entry = &new_bnode->efi_entry;
+
+	entry->var.VendorGuid = EFI_BOOTCACHE_GUID;
+
+	entry->var.Attributes = EFI_VARIABLE_NON_VOLATILE |
+	    EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS;
+
+	/* Save the device driver name and the variable name */
+	var_name_size = strlen(var_name) + 1;
+	if (pdev)
+		device_name_size = strlen(pdev->name) + 1;
+	else
+		device_name_size = 0;
+
+	/* CHeck sizes */
+	if ((device_name_size + var_name_size + 2) > destSize) {
+		pr_err
+		    ("Unable to create full variable name from %s:%s. String is too long.",
+		     new_bnode->device_name, new_bnode->var_name);
+		return NULL;
+	}
+	new_bnode->var_name = kmalloc(var_name_size, GFP_KERNEL);
+	if (!new_bnode->var_name)
+		goto fail;
+
+	strncpy((char *)new_bnode->var_name, var_name, var_name_size);
+
+	if (device_name_size) {
+		new_bnode->device_name = kmalloc(device_name_size, GFP_KERNEL);
+		if (!new_bnode->device_name)
+			goto fail;
+		strncpy((char *)new_bnode->device_name, pdev->name,
+			device_name_size);
+	} else {
+		new_bnode->device_name = NULL;
+	}
+
+	/* Default to false, until someone puts some data in it after we return */
+	new_bnode->is_modified = false;
+
+	/*
+	 * Construct variable name string in u16 chars based on the device_name and the var_name
+	 * <device>:<var_name> or just <var_name> if no device is present.
+	 */
+	if (device_name_size) {
+		sizeCopied =
+		    utf8s_to_utf16s(new_bnode->device_name, device_name_size,
+				    UTF16_HOST_ENDIAN,
+				    (wchar_t *)&entry->var.VariableName,
+				    destSize);
+		/* Insert seperator */
+		entry->var.VariableName[sizeCopied] = (efi_char16_t) ':';
+		sizeCopied++;
+	}
+	sizeCopied +=
+	    utf8s_to_utf16s(new_bnode->var_name, var_name_size,
+			    UTF16_HOST_ENDIAN,
+			    (wchar_t *)&entry->var.VariableName[sizeCopied],
+			    destSize - sizeCopied);
+	entry->var.VariableName[sizeCopied] = (efi_char16_t) '\0';
+
+	if (new_bnode->device_name)
+		pr_debug("Adding new variable with name %s:%s\n",
+			 new_bnode->device_name, new_bnode->var_name);
+	else
+		pr_debug("Adding new variable with name %s\n",
+			 new_bnode->var_name);
+
+	return new_bnode;
+fail:
+	if (new_bnode->var_name)
+		kfree(new_bnode->var_name);
+	if (new_bnode->device_name)
+		kfree(new_bnode->device_name);
+	kfree(new_bnode);
+	return NULL;
+}
+
+/*
+x * Iterater, returning 0 skips this entry
+ */
+static int efi_bootcache_find(struct efivar_entry *entry, void *data)
+{
+	struct bootcache_search *find_var = (struct bootcache_search *)data;
+	struct bootcache_node *bnode = (struct bootcache_node *)entry;
+
+	/*
+	 * Check things.
+	 * 1. Device name matches, or both are null.
+	 * 2. variable name match
+	 */
+
+	/* Check if only one is set, which fails */
+
+	if ((find_var->device_name && !bnode->device_name) ||
+	    (!find_var->device_name && bnode->device_name))
+		return 0;
+
+	if (find_var->device_name && bnode->device_name) {
+		if (strcmp(find_var->device_name, bnode->device_name))
+			return 0;
+	}
+
+	if (!strcmp(find_var->var_name, bnode->var_name)) {
+		find_var->found_node = bnode;
+		pr_debug("Matching Node Found\n");
+		/* So we have a matching node  */
+		return 1;
+	}
+	/* Nothing found, continue iteration */
+	return 0;
+}
+
+/*
+ * Look for an entry in the cache, check if we have a pdev, if not
+ * then we don't check against the device and just the variable
+ */
+int bootcache_get_u32(struct platform_device *pdev, char *var_name,
+		      u32 * var_data)
+{
+	struct bootcache_search find_var;
+
+	int res;
+
+	if (!cache_ready)
+		return -EAGAIN;
+
+	if (!is_warmreset()) {
+		pr_debug("Returning unfound, as not a warm reset\n");
+		return -ENOENT;
+	}
+	if (pdev)
+		pr_debug("Looking up %s:%s\n", pdev->name, var_name);
+	else
+		pr_debug("Looking up %s\n", var_name);
+
+	find_var.var_name = var_name;
+	find_var.device_name = (pdev) ? pdev->name : NULL;
+	find_var.found_node = NULL;
+
+	/* Search, return of 1 indicates we found entry */
+	res = efivar_entry_iter_begin();
+	if (res)
+		return res;
+	res = __efivar_entry_iter(efi_bootcache_find, &efi_bootcache_list,
+				  &find_var, NULL);
+	if ((res) && (find_var.found_node)) {
+		/* Extract data from the node */
+		u32 *tmp = (u32 *) & find_var.found_node->efi_entry.var.Data[0];
+		*var_data = *tmp;
+		efivar_entry_iter_end();
+		return 0;
+	}
+
+	efivar_entry_iter_end();
+	return -ENOENT;
+}
+
+EXPORT_SYMBOL_GPL(bootcache_get_u32);
+
+int bootcache_set_u32(struct platform_device *pdev, char *var_name,
+		      u32 var_data)
+{
+	struct bootcache_search find_var;
+	struct bootcache_node *bnode;
+	int res;
+	if (!cache_ready)
+		return -EAGAIN;
+
+	find_var.var_name = var_name;
+	find_var.device_name = (pdev) ? pdev->name : NULL;
+	find_var.found_node = NULL;
+
+	/* Search, return of 1 indicates we found entry */
+	res = efivar_entry_iter_begin();
+	if (res)
+		return res;
+
+	res = __efivar_entry_iter(efi_bootcache_find, &efi_bootcache_list,
+				  &find_var, NULL);
+
+	if (res) {
+		if (find_var.found_node) {
+			u32 *pData;
+			/* Existing node, update it */
+			pr_debug
+			    ("Existing variable found for %s:%s. Updating.\n",
+			     find_var.device_name, find_var.var_name);
+			bnode = find_var.found_node;
+			pData = (u32 *) & bnode->efi_entry.var.Data[0];
+
+			/* 
+			 * Check if variable is the same, no need to update.
+			 * value of is_modified is not altered, incase it's already been
+			 * set as modified.
+			 */
+			if (find_var.found_node->efi_entry.var.DataSize !=
+			    sizeof(u32) || *pData != var_data) {
+				*pData = var_data;
+				find_var.found_node->efi_entry.var.DataSize =
+				    sizeof(u32);
+				find_var.found_node->is_modified = true;
+			}
+			efivar_entry_iter_end();
+			return 0;
+		} else {
+			efivar_entry_iter_end();
+			return -ENOENT;	/* Some other error condition happened */
+		}
+	} else {
+		/* No entry found, create a new one */
+		pr_debug("No existing variable found for %s:%s\n",
+			 find_var.device_name, find_var.var_name);
+		bnode = efi_bootcache_new(pdev, var_name);
+		if (bnode) {
+			u32 *pData;
+			pData = (u32 *) & bnode->efi_entry.var.Data[0];
+			bnode->is_modified = true;
+			bnode->efi_entry.var.DataSize = sizeof(u32);
+			*pData = var_data;
+			/* Add to the list */
+			efivar_entry_iter_end();
+			res =
+			    efivar_entry_add(&bnode->efi_entry,
+					     &efi_bootcache_list);
+			if (res) {
+				efi_bootcache_free(bnode);
+				return res;
+			}
+			return 0;
+		} else {
+			pr_debug("No new node was created.\n");
+			efivar_entry_iter_end();
+			return -ENOMEM;
+		}
+	}
+}
+
+EXPORT_SYMBOL_GPL(bootcache_set_u32);
+
+/*
+ * Dump out the debugging info on what's cached
+ */
+void bootcache_dbg()
+{
+	if (!cache_ready)
+		return;
+
+	pr_debug("Entries cached : %d \n", envCount);
+	efivar_entry_iter(efi_bootcache_print_entry, &efi_bootcache_list, NULL);
+
+}
+
+EXPORT_SYMBOL_GPL(bootcache_dbg);
+
+/*
+ * Write out any changed variables
+ */
+
+void bootcache_writeout(void)
+{
+	if (!cache_ready)
+		return;
+
+	__efivar_entry_iter(efi_bootcache_write_entry, &efi_bootcache_list,
+			    NULL, NULL);
+}
+
+EXPORT_SYMBOL_GPL(bootcache_writeout);
+
+static void efi_bootcache_add_entry(struct bootcache_node *new_node)
+{
+	struct efi_variable *var;
+	struct efivar_entry *entry;
+	unsigned long size;
+	int ret;
+	char *var_name;
+	char *device_name;
+	char *variable_part;
+	unsigned long var_name_size;
+	unsigned long utf8_name_size;
+
+	if (!new_node)
+		return;
+
+	entry = &(new_node->efi_entry);
+
+	/*
+	 * TODO: Extract device name and variable name from the EFI variable
+	 * name here look for a ":" and if it exists, use anything before that as the
+	 * device name.
+	 */
+
+	utf8_name_size = ucs2_utf8size(entry->var.VariableName);
+	var_name_size = utf8_name_size + 1;
+	var_name = kmalloc(var_name_size, GFP_KERNEL);
+	device_name = kmalloc(var_name_size, GFP_KERNEL);
+
+	if ((!var_name) || (!device_name))
+		goto mem_fail;
+
+	/* Copy variable into device name and terminate with a null */
+	ucs2_as_utf8(device_name, entry->var.VariableName, var_name_size);
+	device_name[utf8_name_size + 1] = '\0';
+	/* Check for ":" character */
+	variable_part = strnstr(device_name, ":", var_name_size);
+
+	if (variable_part) {
+		/* Copy variable part over, then terminate the existing string */
+		strncpy(var_name, variable_part + 1, var_name_size);
+		variable_part[0] = '\0';
+	} else {
+		/* Copy over variable part, clear device_name */
+		strncpy(var_name, device_name, var_name_size);
+		kfree(device_name);
+		device_name = NULL;
+	}
+
+	new_node->device_name = device_name;
+	new_node->var_name = var_name;
+
+	if (efivar_entry_add(entry, &efi_bootcache_list)) {
+		/* Free it */
+		kfree(new_node);
+		return;
+	}
+	envCount++;
+
+	/* Do an initial read of the variable */
+	var = &entry->var;
+	size = sizeof(var->Data);
+
+	ret = efivar_entry_get(entry, &var->Attributes, &size, var->Data);
+	var->DataSize = size;
+	if (ret)
+		pr_debug("Failed to read variable.\n");
+	return;
+
+mem_fail:
+	if (var_name)
+		kfree(var_name);
+	if (device_name)
+		kfree(device_name);
+	return;
+}
+
+#ifdef TESTING_MODE
+/*
+ * Some debugging bits, prints out variable names+guid
+ */
+static void efi_print_variablename(efi_char16_t * name, efi_guid_t vendor)
+{
+	char *namebuffer;
+	int len;
+	len = ucs2_utf8size(name);
+	/* name, plus '-', plus GUID, plus NUL */
+	namebuffer = kmalloc(len + 1 + EFI_VARIABLE_GUID_LEN + 1, GFP_KERNEL);
+	if (!namebuffer)
+		return;
+
+	/* Convert it over and put into the buffer.
+	 * append the GUID and then null terminate
+	 */
+	ucs2_as_utf8(namebuffer, name, len);
+
+	namebuffer[len] = '-';
+	efi_guid_to_str(&vendor, namebuffer + len + 1);
+	namebuffer[len + EFI_VARIABLE_GUID_LEN + 1] = '\0';
+
+	pr_debug("Found - %s\n", namebuffer);
+	kfree(namebuffer);
+}
+#endif
+
+static int efi_bootcache_callback(efi_char16_t * name, efi_guid_t vendor,
+				  unsigned long name_size, void *data)
+{
+	struct bootcache_node *cache_node;
+
+#ifdef TESTING_MODE
+	efi_print_variablename(name, vendor);
+#endif
+	/* Check GUID, if not a match return to skip this node */
+	if (!guid_equal(&vendor, &EFI_BOOTCACHE_GUID))
+		return 0;
+
+	/* Allocate a note */
+	cache_node = kmalloc(sizeof(*cache_node), GFP_KERNEL);
+	if (!cache_node)
+		return -ENOMEM;
+
+	guid_copy(&(cache_node->efi_entry.var.VendorGuid), &vendor);
+	memcpy(cache_node->efi_entry.var.VariableName, name, name_size);
+	cache_node->is_modified = false;
+	efi_bootcache_add_entry(cache_node);
+
+	return 0;
+}
+
+/*
+ * Start up code. Will check if EFI is writable, 
+ * parse all the existing variables and cache those
+ * which are of interest
+ */
+
+static int __init bootcache_init(void)
+{
+	// print the warmreset status
+	if (is_warmreset())
+		pr_debug("Warm Boot\n");
+	else
+		pr_debug("Cold Boot\n");
+
+	if (!efivar_supports_writes()) {
+		pr_err("efi_bootcache: No Writable efi variables available.\n");
+		return 0;
+	}
+
+	pr_info("EFI Bootcache Facility v%s %s\n", EFI_BOOTCACHE_VERSION,
+		EFI_BOOTCACHE_DATE);
+
+	efivar_init(efi_bootcache_callback, NULL, true, &efi_bootcache_list);
+
+	pr_debug("Entries cached : %d \n", envCount);
+#ifdef TESTING_MODE
+	bootcache_dbg();
+#endif
+
+	/* Register a reboot handler, so we can write variables out */
+	register_reboot_notifier(&bootcache_notifier);
+
+	cache_ready = true;
+	return 0;
+}
+
+/*
+ * Needs to be loaded before drivers so the serivce
+ * is available to them.
+ */
+subsys_initcall(bootcache_init);
diff --git a/include/linux/efi-bootcache.h b/include/linux/efi-bootcache.h
new file mode 100644
index 000000000000..d9fa8847e948
--- /dev/null
+++ b/include/linux/efi-bootcache.h
@@ -0,0 +1,11 @@
+#ifndef _LINUX_EFI_BOOTCACHE_H
+#define _LINUX_EFI_BOOTCACHE_H
+
+#include <linux/efi.h>
+#include <linux/platform_device.h>
+int bootcache_get_u32(struct platform_device *, char *, u32 *);
+int bootcache_set_u32(struct platform_device *, char *, u32);
+void bootcache_writeout(void);
+void bootcache_dbg(void);
+
+#endif /* _LINUX_EFI_BOOTCACHE_H */
